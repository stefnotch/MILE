<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- https://stackoverflow.com/a/68051929/3492994 -->
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg width='32' height='32' xmlns='http://www.w3.org/2000/svg'%3E%3Cg id='Layer_1'%3E%3Ctitle%3ELayer 1%3C/title%3E%3Ctext xml:space='preserve' text-anchor='start' font-family='Noto Sans JP' font-size='24' id='svg_1' y='25' x='5' stroke-width='0' stroke='%23000' fill='%23000000'%3EM%3C/text%3E%3C/g%3E%3C/svg%3E"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MILE</title>
    <!-- <link rel="stylesheet" href="https://raw.githubusercontent.com/Jah-On/MILE/main/MILE.css">
        <script src="https://raw.githubusercontent.com/Jah-On/MILE/main/MILE.js"></script> -->
    
    <script type="module" crossorigin>
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
const style = "";
const singleChar = {
  "aleph": "â„µ",
  "cns": "â„‚",
  "ens": "âˆ…",
  "infinity": "âˆž",
  "ins": "â„¤",
  "nns": "â„•",
  "'": "'",
  "prime": "'",
  "rans": "â„š",
  "rens": "â„"
};
const leftOne = {
  "abs": "",
  "sqrt": ""
};
const leftOneChar = {
  "-": "âˆ’",
  "minus": "âˆ’",
  "neg": "Â¬",
  "+": "+",
  "plus": "+"
};
const operators = {
  "coprod": "âˆ",
  "int": "âˆ«",
  "iint": "âˆ¬",
  "iiint": "âˆ­",
  "lim": "lim",
  "liminf": "lim inf",
  "limsup": "lim sup",
  "lint": "âˆ®",
  "llint": "âˆ¯",
  "lllint": "âˆ°",
  "prod": "âˆ",
  "sum": "âˆ‘"
};
const leftTwo = {
  "frac": "",
  "logbase": ""
};
const middleTwo = {
  "^": "",
  "pow": ""
};
const middleTwoChar = {
  "and": "â‹€",
  "approx": "â‰ˆ",
  "cdot": "âŠ™",
  "copen": "â—¯",
  "cminus": "âŠ–",
  "cplus": "âŠ•",
  "cslash": "âŠ˜",
  "ctimes": "âŠ—",
  "def": "â‰",
  "/": "/",
  "div": "Ã·",
  "|": "âˆ£",
  "divides": "âˆ£",
  "dlarrow": "â‡",
  "dlrarrow": "â‡”",
  "drarrow": "â‡’",
  "=": "=",
  "equals": "=",
  "equiv": "â‰¡",
  ">": ">",
  "gthan": ">",
  "gethan": "â‰¥",
  "geslant": "â©¾",
  "in": "âˆˆ",
  "imgof": "âŠ·",
  "intersect": "âˆ©",
  "<": "<",
  "lthan": "<",
  "lethan": "â‰¤",
  "leslant": "â©½",
  "mgthan": "â‰«",
  "mlthan": "â‰ª",
  "ndivides": "âˆ¤",
  "noteq": "â‰ ",
  "notin": "âˆ‰",
  "nprec": "âŠ€",
  "nsucc": "âŠ",
  "nsubset": "âŠ„",
  "nsubsete": "âŠˆ",
  "nsupset": "âŠ…",
  "nsupsete": "âŠ‰",
  "owns": "âˆ‹",
  "or": "âˆ¨",
  "origof": "âŠ¶",
  "ortho": "âŸ‚",
  "parallel": "âˆ¥",
  "prec": "â‰º",
  "preceq": "â‰¼",
  "precsim": "â‰¾",
  "prop": "âˆ",
  "setm": "\\",
  "setq": "/",
  "sim": "âˆ¼",
  "simeq": "â‰ƒ",
  "stimes": "*",
  "subset": "âŠ‚",
  "subsete": "âŠ†",
  "succ": "â‰»",
  "succeq": "â‰½",
  "succsim": "â‰¿",
  "supset": "âŠƒ",
  "supsete": "âŠ‡",
  "*": "â‹…",
  "times": "â‹…",
  "toward": "âžœ",
  "union": "âˆª",
  "xtimes": "Ã—"
};
const MLNameSpace = "http://www.w3.org/1998/Math/MathML";
function isAlpha(char) {
  return /^[a-zA-Z]+$/.test(char);
}
function isNumber(char) {
  return /^[0-9]+$/.test(char);
}
function generateRand16() {
  let returnString = "";
  for (let index = 0; index < 16; ++index) {
    returnString = returnString + String.fromCharCode(
      Math.random() * 10 + 48
    );
  }
  return returnString;
}
function generateID(IDString) {
  if (IDString.length == 0) {
    return [generateRand16(), false];
  }
  if (document.getElementById(IDString) == null) {
    return [IDString, true];
  }
  let newID = IDString;
  while (document.getElementById(newID) != null) {
    if (isAlpha(newID[newID.length - 1]) && newID[newID.length - 1] != "z") {
      newID = newID.substring(0, newID.length - 1) + String.fromCharCode(newID[newID.length - 1].charCodeAt() + 1);
    } else {
      newID = newID + "a";
    }
  }
  return [newID, true];
}
function functionPositionAndInputs(functionNameString) {
  if (singleChar.hasOwnProperty(functionNameString)) {
    return [0, 0];
  }
  if (leftOne.hasOwnProperty(functionNameString) || leftOneChar.hasOwnProperty(functionNameString) || operators.hasOwnProperty(functionNameString)) {
    return [0, 1];
  }
  if (leftTwo.hasOwnProperty(functionNameString)) {
    return [0, 2];
  }
  if (operators.hasOwnProperty(functionNameString.slice(0, -1))) {
    if (functionNameString.slice(-1) == "o" || functionNameString.slice(-1) == "u") {
      return [0, 2];
    }
    if (functionNameString.slice(-1) == "b") {
      return [0, 3];
    }
  }
  if (middleTwo.hasOwnProperty(functionNameString) || middleTwoChar.hasOwnProperty(functionNameString)) {
    return [1, 2];
  }
  return [-1, -1];
}
function parse(segmentString) {
  let tokens = [];
  let currentFuncStart = -1;
  let currentGroupStart = -1;
  let currentSubStart = -1;
  let semicolSegments = 0;
  let shownSegments = 0;
  let isFunction = [-1, -1];
  let currentChar = "";
  for (let index = 0; index < segmentString.length; ++index) {
    currentChar = segmentString[index];
    if (isAlpha(currentChar) && shownSegments + semicolSegments == 0) {
      if (currentGroupStart == -1) {
        currentGroupStart = index;
      }
      if (currentFuncStart == -1) {
        currentFuncStart = index;
      } else {
        isFunction = functionPositionAndInputs(segmentString.substring(currentFuncStart, index + 1));
        if (isFunction[1] != -1) {
          if (currentGroupStart != currentFuncStart) {
            tokens.push([2, segmentString.substring(currentGroupStart, currentFuncStart)]);
          }
          if (index + 1 == segmentString.length) {
            tokens.push([0, segmentString.substring(currentFuncStart, index + 1), isFunction[0], isFunction[1]]);
            currentGroupStart = -1;
            continue;
          }
          if (!isAlpha(segmentString[index + 1])) {
            tokens.push([0, segmentString.substring(currentFuncStart, index + 1), isFunction[0], isFunction[1]]);
            currentGroupStart = -1;
          }
        }
      }
      continue;
    }
    switch (currentChar) {
      case " ":
        if (currentGroupStart != -1 && shownSegments + semicolSegments == 0) {
          tokens.push([2, segmentString.substring(currentGroupStart, index)]);
          currentGroupStart = -1;
        }
        currentFuncStart = -1;
        continue;
      case "(":
      case "[":
      case "{":
        if (currentGroupStart != -1 && shownSegments + semicolSegments == 0) {
          tokens.push([2, segmentString.substring(currentGroupStart, index)]);
          currentGroupStart = -1;
        }
        shownSegments++;
        if (currentSubStart == -1) {
          currentSubStart = index;
        }
        continue;
      case ")":
      case "]":
      case "}":
        if (shownSegments > 0) {
          shownSegments--;
          if (shownSegments == 0 && shownSegments + semicolSegments == 0) {
            tokens.push([1, segmentString.substring(currentSubStart, index + 1)]);
            currentSubStart = -1;
            currentGroupStart = -1;
          }
        }
        continue;
      case ";":
        if (index + 1 < segmentString.length) {
          if (segmentString[index + 1] == ";") {
            if (semicolSegments == 1) {
              tokens.push([1, segmentString.substring(currentSubStart, index + 2)]);
              currentSubStart = -1;
              currentGroupStart = -1;
              --semicolSegments;
              ++index;
            } else if (semicolSegments > 0) {
              --semicolSegments;
              ++index;
            }
          } else {
            if (currentGroupStart != -1 && shownSegments + semicolSegments == 0) {
              tokens.push([2, segmentString.substring(currentGroupStart, index)]);
              currentGroupStart = -1;
            }
            if (currentSubStart == -1) {
              currentSubStart = index;
            }
            semicolSegments++;
          }
        }
        continue;
      default:
        isFunction = functionPositionAndInputs(currentChar);
        if (isFunction[1] != -1 && shownSegments + semicolSegments == 0) {
          if (currentGroupStart != -1) {
            tokens.push([2, segmentString.substring(currentGroupStart, index)]);
          }
          currentGroupStart = -1;
          tokens.push([0, segmentString.substring(index, index + 1), isFunction[0], isFunction[1]]);
        } else if (currentGroupStart == -1 && shownSegments + semicolSegments == 0) {
          currentGroupStart = index;
        }
        continue;
    }
  }
  if (currentSubStart != -1) {
    tokens.push([1, segmentString.substring(currentSubStart, segmentString.length)]);
  } else if (currentGroupStart != -1) {
    tokens.push([2, segmentString.substring(currentGroupStart, segmentString.length)]);
  }
  return tokens;
}
function processLeftFunction(functionToken, tokensRight) {
  let accumulator = [];
  for (let index = 0; index < functionToken[3]; ++index) {
    if (index < tokensRight.length) {
      accumulator.push(tokensRight[index][1]);
    } else {
      accumulator.push(document.createElementNS(MLNameSpace, "mtext"));
      accumulator[accumulator.length - 1].append(document.createTextNode("Â¿"));
    }
  }
  return functionToHTML(functionToken[1], accumulator);
}
function processMiddleFunction(functionToken, tokenLeft, tokenRight) {
  let accumulator = [];
  if (tokenLeft.length > 0) {
    accumulator.push(link(parse(tokenLeft[0][1])));
  } else {
    accumulator.push(document.createElementNS(MLNameSpace, "mtext"));
    accumulator[accumulator.length - 1].append(document.createTextNode("Â¿"));
  }
  if (tokenRight.length > 0) {
    accumulator.push(tokenRight[0][1]);
  } else {
    accumulator.push(document.createElementNS(MLNameSpace, "mtext"));
    accumulator[accumulator.length - 1].append(document.createTextNode("Â¿"));
  }
  return functionToHTML(functionToken[1], accumulator);
}
function processSub(inputToken) {
  if (inputToken[1].length < 2) {
    return processGroup(inputToken);
  }
  if (inputToken[1][0] == ";") {
    if (/[;]/.test(inputToken[1][inputToken[1].length - 2]) && inputToken[1][inputToken[1].length - 2] == inputToken[1][inputToken[1].length - 1]) {
      return link(parse(inputToken[1].substring(1, inputToken[1].length - 2)));
    } else if (/[;]/.test(inputToken[1][inputToken[1].length - 1])) {
      return link(parse(inputToken[1].substring(1, inputToken[1].length - 1)));
    } else {
      return link(parse(inputToken[1].substring(1, inputToken[1].length)));
    }
  }
  let endsWithVisible = /^[\)\]\}\|]+$/.test(inputToken[1][inputToken[1].length - 1]);
  let outputElement = document.createElementNS(MLNameSpace, "mrow");
  outputElement.append(document.createElementNS(MLNameSpace, "mo"));
  outputElement.lastChild.append(document.createTextNode(inputToken[1][0]));
  outputElement.append(link(parse(inputToken[1].substring(1, inputToken[1].length - Number(endsWithVisible)))));
  if (endsWithVisible) {
    outputElement.append(document.createElementNS(MLNameSpace, "mo"));
    outputElement.lastChild.append(document.createTextNode(inputToken[1][inputToken[1].length - 1]));
  }
  return outputElement;
}
function processGroup(inputToken) {
  let outputElement = document.createElementNS(MLNameSpace, "mrow");
  for (let i = 0; i < inputToken[1].length; i++) {
    const char = inputToken[1][i];
    if (isAlpha(char)) {
      outputElement.append(document.createElementNS(MLNameSpace, "mi"));
    } else if (isNumber(char)) {
      outputElement.append(document.createElementNS(MLNameSpace, "mn"));
    } else {
      outputElement.append(document.createElementNS(MLNameSpace, "mtext"));
    }
    outputElement.lastChild.append(document.createTextNode(char));
  }
  return outputElement;
}
function functionToHTML(funcName, argElements) {
  funcName = funcName.replace("^", "pow").replace("'", "prime").replace("-", "minus").replace("+", "plus").replace("|", "divides").replace("=", "equals").replace(">", "gthan").replace("<", "lthan").replace("*", "times");
  let outputElement = document.createElementNS(MLNameSpace, "mrow");
  outputElement.setAttribute("displaystyle", "true");
  if (funcName == "abs") {
    outputElement.append(document.createElementNS(MLNameSpace, "mo"));
    outputElement.lastChild.append(document.createTextNode("|"));
    outputElement.append(argElements[0]);
    outputElement.append(document.createElementNS(MLNameSpace, "mo"));
    outputElement.lastChild.append(document.createTextNode("|"));
    return outputElement;
  }
  if (funcName == "frac") {
    outputElement.append(document.createElementNS(MLNameSpace, "mfrac"));
    outputElement.lastChild.append(argElements[0]);
    outputElement.lastChild.append(argElements[1]);
    return outputElement;
  }
  if (funcName == "logbase") {
    outputElement.append(document.createElementNS(MLNameSpace, "msub"));
    outputElement.lastChild.append(document.createElementNS(MLNameSpace, "mtext"));
    outputElement.lastChild.lastChild.append(document.createTextNode("log"));
    outputElement.lastChild.append(argElements[0]);
    outputElement.append(argElements[1]);
    return outputElement;
  }
  if (funcName == "pow") {
    outputElement.append(document.createElementNS(MLNameSpace, "msup"));
    outputElement.lastChild.append(argElements[0]);
    outputElement.lastChild.append(argElements[1]);
    return outputElement;
  }
  if (funcName == "sqrt") {
    outputElement.append(document.createElementNS(MLNameSpace, "msqrt"));
    outputElement.lastChild.append(argElements[0]);
    return outputElement;
  }
  if (singleChar.hasOwnProperty(funcName)) {
    outputElement.append(document.createElementNS(MLNameSpace, "mtext"));
    outputElement.lastChild.append(document.createTextNode(singleChar[funcName]));
    return outputElement;
  }
  if (leftOneChar.hasOwnProperty(funcName)) {
    outputElement.append(document.createElementNS(MLNameSpace, "mo"));
    outputElement.lastChild.append(document.createTextNode(leftOneChar[funcName]));
    outputElement.append(argElements[0]);
    return outputElement;
  }
  if (operators.hasOwnProperty(funcName)) {
    outputElement.append(document.createElement("mo"));
    outputElement.lastChild.setAttribute("largeop", "true");
    outputElement.lastChild.append(document.createTextNode(operators[funcName]));
    outputElement.append(argElements[0]);
    return outputElement;
  }
  if (operators.hasOwnProperty(funcName.slice(0, -1))) {
    if (funcName.slice(-1) == "o") {
      outputElement.append(document.createElementNS(MLNameSpace, "mover"));
      outputElement.lastChild.append(document.createElementNS(MLNameSpace, "mo"));
      outputElement.lastChild.setAttribute("largeop", "true");
      outputElement.lastChild.lastChild.append(document.createTextNode(operators[funcName.substr(0, funcName.length - 1)]));
      outputElement.lastChild.append(argElements[0]);
      outputElement.append(argElements[1]);
      return outputElement;
    }
    if (funcName.slice(-1) == "u") {
      outputElement.append(document.createElementNS(MLNameSpace, "munder"));
      outputElement.lastChild.append(document.createElementNS(MLNameSpace, "mo"));
      outputElement.lastChild.setAttribute("largeop", "true");
      outputElement.lastChild.lastChild.append(document.createTextNode(operators[funcName.substr(0, funcName.length - 1)]));
      outputElement.lastChild.append(argElements[0]);
      outputElement.append(argElements[1]);
      return outputElement;
    }
    if (funcName.slice(-1) == "b") {
      outputElement.append(document.createElementNS(MLNameSpace, "munderover"));
      outputElement.lastChild.append(document.createElementNS(MLNameSpace, "mo"));
      outputElement.lastChild.setAttribute("largeop", "true");
      outputElement.lastChild.lastChild.append(document.createTextNode(operators[funcName.substr(0, funcName.length - 1)]));
      outputElement.lastChild.append(argElements[1]);
      outputElement.lastChild.append(argElements[0]);
      outputElement.append(argElements[2]);
      return outputElement;
    }
  }
  if (middleTwoChar.hasOwnProperty(funcName)) {
    outputElement.append(argElements[0]);
    outputElement.append(document.createElementNS(MLNameSpace, "mo"));
    outputElement.lastChild.append(document.createTextNode(middleTwoChar[funcName]));
    outputElement.append(argElements[1]);
    return outputElement;
  }
  return outputElement;
}
function link(tokens) {
  for (let index = tokens.length - 1; index >= 0; --index) {
    if (tokens[index][0] == 0) {
      if (tokens[index][2] == 0) {
        tokens[index][1] = processLeftFunction(tokens[index], tokens.slice(index + 1, index + 1 + tokens[index][3]));
        tokens.splice(index + 1, Math.min(tokens.length - index, tokens[index][3]));
      } else {
        tokens[index][1] = processMiddleFunction(tokens[index], tokens.slice(index - 1, index), tokens.slice(index + 1, index + 2));
        tokens.splice(index + 1, 1);
        if (index != 0) {
          tokens.splice(index - 1, 1);
        }
        --index;
      }
    } else if (tokens[index][0] == 1) {
      tokens[index][1] = processSub(tokens[index]);
    } else {
      tokens[index][1] = processGroup(tokens[index]);
    }
  }
  let outputElement = document.createElementNS(MLNameSpace, "math");
  for (let index = 0; index < tokens.length; ++index) {
    outputElement.append(tokens[index][1]);
    if (index + 1 == tokens.length) {
      continue;
    }
    if (tokens[index][0] == tokens[index + 1][0] && tokens[index][0] == 2) {
      outputElement.innerText += " ";
    }
  }
  return outputElement;
}
function onEvent(inputElement) {
  let segments = [];
  let endStartIndex = -1;
  let userInput = inputElement.value.replaceAll("\n", " ").replaceAll("+-", "Â±").replaceAll("-+", "âˆ“");
  let outputElement = document.getElementById("output");
  outputElement.innerHTML = "";
  for (let index = 0; index < userInput.length; ++index) {
    if (userInput.substr(index, 3).toLowerCase() == "end") {
      endStartIndex = index;
    } else if (endStartIndex != -1 && !isAlpha(userInput[index]) && (index - endStartIndex) % 4 == 3) {
      segments.push(userInput.substring(0, endStartIndex));
      userInput = userInput.substring(index, userInput.length);
      endStartIndex = -1;
      index = 0;
    }
  }
  if (endStartIndex != -1) {
    segments.push(userInput.substring(0, endStartIndex));
  } else {
    segments.push(userInput);
  }
  for (let index = 0; index < segments.length; ++index) {
    outputElement.append(link(parse(segments[index])));
    outputElement.lastChild.className = "segment";
  }
  let visibleFronts = document.getElementsByClassName("visibleFront");
  for (let index = 0; index < visibleFronts.length; ++index) {
    visibleFronts[index].style.transform = `scaleY(${visibleFronts[index].nextSibling.clientHeight / visibleFronts[index].clientHeight}`;
  }
  let visibleBacks = document.getElementsByClassName("visibleBack");
  for (let index = 0; index < visibleBacks.length; ++index) {
    visibleBacks[index].style.transform = `scaleY(${visibleBacks[index].previousSibling.clientHeight / visibleBacks[index].clientHeight}`;
  }
  inputElement.setAttribute("data", outputElement.innerHTML);
}
function printOutput() {
  window.print();
}
function windowLeave(event) {
  event.preventDefault();
  return "";
}
function updateName(event) {
  let newID = generateID(event.srcElement.value);
  document.getElementById(event.srcElement.getAttribute("data")).setAttribute("showID", String(newID[1]));
  document.getElementById(event.srcElement.getAttribute("data")).id = newID[0];
  for (let index = 0; index < event.srcElement.parentNode.childNodes.length; ++index) {
    event.srcElement.parentNode.childNodes[index].setAttribute("data", newID[0]);
  }
  updateBaseOutput();
}
function moveInputUp(event) {
  let inputElement = document.getElementById(event.srcElement.getAttribute("data"));
  let previousElement = event.srcElement.parentNode.previousSibling;
  if (previousElement) {
    event.srcElement.parentNode.parentNode.insertBefore(event.srcElement.parentNode, previousElement);
    inputElement.parentNode.insertBefore(inputElement, inputElement.previousSibling);
  }
  updateBaseOutput();
}
function moveInputDown(event) {
  let inputElement = document.getElementById(event.srcElement.getAttribute("data"));
  let nextElement = event.srcElement.parentNode.nextSibling;
  if (nextElement) {
    event.srcElement.parentNode.parentNode.insertBefore(nextElement, event.srcElement.parentNode);
    inputElement.parentNode.insertBefore(inputElement.nextSibling, inputElement);
  }
  updateBaseOutput();
}
function copyInput(event) {
  let inputElement = document.getElementById(event.srcElement.getAttribute("data"));
  let newID = generateID(event.srcElement.getAttribute("data"));
  inputElement.insertAdjacentElement("afterend", newInputElement(newID[0], newID[1]));
  document.getElementById(newID[0]).setAttribute("data", inputElement.getAttribute("data"));
  document.getElementById(newID[0]).value = inputElement.value;
  document.getElementById(newID[0]).setAttribute("showID", inputElement.getAttribute("showID"));
  event.srcElement.parentNode.insertAdjacentElement("afterend", newProblemTableRow(newID[0], inputElement.getAttribute("showID") == "true"));
  document.getElementById("problemList").lastChild.scrollIntoView();
  updateBaseOutput();
}
function deleteInput(event) {
  event.srcElement.parentNode.remove();
  document.getElementById(event.srcElement.getAttribute("data")).remove();
  updateBaseOutput();
}
function editInput(event) {
  document.getElementById("baseForm").hidden = true;
  document.getElementById("problemList").hidden = true;
  document.getElementById("backToBase").hidden = false;
  document.getElementById("backToBase").setAttribute("data", event.srcElement.getAttribute("data"));
  document.getElementById(event.srcElement.getAttribute("data")).hidden = false;
  document.getElementById(event.srcElement.getAttribute("data")).focus();
  document.getElementById("output").innerHTML = document.getElementById(event.srcElement.getAttribute("data")).getAttribute("data");
}
function backToBase(event) {
  document.getElementById("baseForm").hidden = false;
  document.getElementById("problemList").hidden = false;
  document.getElementById("backToBase").hidden = true;
  document.getElementById(event.srcElement.getAttribute("data")).hidden = true;
  updateBaseOutput();
}
function newInputElement(id, showID) {
  let newInput = document.createElement("textarea");
  newInput.className = "input";
  newInput.id = id;
  newInput.addEventListener("input", function() {
    onEvent(this);
  });
  newInput.setAttribute("data", "");
  newInput.setAttribute("showID", String(showID));
  newInput.hidden = true;
  return newInput;
}
function newProblemTableRow(inputID, visibleID) {
  let rowDiv = document.createElement("div");
  rowDiv.className = "problemListRow";
  let nameInput = document.createElement("input");
  nameInput.type = "text";
  nameInput.className = "problemName";
  if (visibleID) {
    nameInput.value = inputID;
  }
  nameInput.setAttribute("data", inputID);
  nameInput.addEventListener("input", updateName);
  let moveUp = document.createElement("button");
  moveUp.className = "editProblem";
  moveUp.textContent = "Move Up";
  moveUp.setAttribute("data", inputID);
  moveUp.addEventListener("click", moveInputUp);
  let moveDown = document.createElement("button");
  moveDown.className = "editProblem";
  moveDown.textContent = "Move Down";
  moveDown.setAttribute("data", inputID);
  moveDown.addEventListener("click", moveInputDown);
  let copy = document.createElement("button");
  copy.className = "editProblem";
  copy.textContent = "Copy";
  copy.setAttribute("data", inputID);
  copy.addEventListener("click", copyInput);
  let remove = document.createElement("button");
  remove.className = "editProblem";
  remove.textContent = "Delete";
  remove.setAttribute("data", inputID);
  remove.addEventListener("click", deleteInput);
  let edit = document.createElement("button");
  edit.className = "editProblem";
  edit.textContent = "Edit";
  edit.setAttribute("data", inputID);
  edit.addEventListener("click", editInput);
  rowDiv.append(nameInput, moveUp, moveDown, copy, remove, edit);
  return rowDiv;
}
function addNewInput() {
  let problemNameInput = document.getElementById("baseForm").children[0];
  let problemList = document.getElementById("problemList");
  let ID = generateID(problemNameInput.value);
  document.getElementById("inputs").append(newInputElement(ID[0], ID[1]));
  problemList.append(newProblemTableRow(ID[0], ID[1]));
  problemNameInput.value = "";
  problemList.lastChild.scrollIntoView();
  updateBaseOutput();
}
function updateBaseOutput() {
  let outputElement = document.getElementById("output");
  outputElement.innerHTML = "";
  const inputElements = document.getElementsByClassName("input");
  for (let index = 0; index < inputElements.length; ++index) {
    let problem = document.createElement("div");
    problem.className = "baseOutput";
    let label = document.createElement("span");
    if (inputElements[index].getAttribute("showID") == "true") {
      label.innerText = inputElements[index].id + ".";
    }
    label.className = "baseOutputLabel";
    let contents = document.createElement("div");
    contents.innerHTML = inputElements[index].getAttribute("data");
    contents.className = "baseOutputContents";
    problem.append(label, contents);
    outputElement.append(problem);
    if (index == inputElements.length - 1) {
      contents.scrollIntoView();
    }
  }
}
window.addEventListener("beforeunload", windowLeave);
document.getElementById("baseForm").addEventListener("submit", addNewInput);
document.getElementById("backToBase").addEventListener("click", backToBase);
document.getElementById("printButton").addEventListener("click", printOutput);

</script>
    <style>
body {
  background-color: black;
  height: calc(100vh - 20px);
  margin: 0px;
  padding: 10px;
}

span {
  display: inline-block;
  line-height: 0.8;
  vertical-align: middle;
}

@media print {
  #header,
  #inputs {
    visibility: hidden;
  }
  #output {
    position: absolute;
    top: 0px;
    left: 0px;
    min-width: calc(100% - 8px);
    height: fit-content !important;
    overflow-y: visible;
    margin: 0px;
  }
  #output * {
    break-inside: avoid;
  }
  #container,
  body,
  html {
    height: fit-content !important;
    width: 100%;
    padding: 0px;
    margin: 0px;
  }
}

/* HEADER START */
#header {
  display: flex;
  margin-bottom: 10px;
  width: 100%;
  height: 25px;
}

#baseForm {
  width: fit-content;
}

#printButton {
  margin-left: auto;
}
/* HEADER END */

#container {
  display: flex;
  width: 100%;
  height: calc(100% - 30px);
}

#problemList {
  font-size: 32px;
  margin-left: 10px;
  background-color: rgb(20, 20, 20);
  overflow-y: auto;
  width: calc(100% - 10px);
}

div.problemListRow {
  display: flex;
  flex-direction: row;
  margin-top: 10px;
}

input.problemName {
  width: 40%;
}

button.editProblem {
  margin: auto;
  vertical-align: baseline;
}

textarea.input {
  width: calc(100% - 10px);
  height: calc(100% - 10px);
  font-size: 28px;
  background-color: rgb(20, 20, 20);
  color: whitesmoke;
  margin: 0px;
  resize: none;
}

#inputs {
  width: calc(50% - 10px);
  height: calc(100% - 2px);
  font-size: 28px;
  background-color: rgb(20, 20, 20);
  overflow-y: scroll;
}

#output {
  width: calc(50% - 10px);
  height: calc(100% - 12px);
  font-size: 28px;
  background-color: whitesmoke;
  color: black;
  align-items: center;
  display: block;
  margin-left: auto;
  padding: 5px;
  overflow-y: scroll;
}

div.baseOutput {
  display: flex;
  width: calc(100% - 4px);
  margin-bottom: 10px;
  border: 2px solid black;
}

span.baseOutputLabel {
  position: relative;
  top: 0px;
  left: 5px;
  z-index: 2;
  display: block;
}

div.baseOutputContents {
  display: block;
  position: relative;
  top: 0px;
  z-index: 1;
  margin-left: auto;
  margin-right: auto;
}

math.segment {
  display: block;
  margin-bottom: 10px;
  break-inside: avoid;
  margin-left: auto;
  margin-right: auto;
  width: fit-content;
}

/* Group CSS */

/* Sub Segment CSS */

/* OP CSS */

</style>
  </head>
  <body>
    <div id="header">
      <form id="baseForm" method="dialog">
        <input type="text" placeholder="Problem name or number" />
        <button>Add</button>
      </form>
      <input type="button" id="backToBase" value="ðŸ¡¸ Back" hidden />
      <input type="button" id="printButton" value="Print" />
    </div>
    <div id="container">
      <div id="inputs">
        <div id="problemList"></div>
      </div>
      <div id="output"></div>
    </div>
    
    
    
    
    
    
    
    
    <!---
    
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
-->
  </body>
  <!-- <script>window.onload = onEvent();</script> -->
</html>
